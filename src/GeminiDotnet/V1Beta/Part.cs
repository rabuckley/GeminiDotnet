using System.Text.Json;
using System.Text.Json.Serialization;

namespace GeminiDotnet.V1Beta;

/// <summary>
/// A datatype containing media that is part of a multi-part <see cref="V1Beta.Content"/> message.
/// A <see cref="V1Beta.Part"/> consists of data which has an associated datatype. A <see cref="V1Beta.Part"/> can only
/// contain one of the accepted types in <c>Part.data</c>.
/// A <see cref="V1Beta.Part"/> must have a fixed IANA MIME type identifying the type and subtype
/// of the media if the <c>inline_data</c> field is filled with raw bytes.
/// </summary>
public sealed record Part
{
    /// <summary>
    /// Result of executing the <see cref="V1Beta.ExecutableCode"/>.
    /// </summary>
    [JsonPropertyName("codeExecutionResult")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public CodeExecutionResult? CodeExecutionResult { get; init; }

    /// <summary>
    /// Code generated by the model that is meant to be executed.
    /// </summary>
    [JsonPropertyName("executableCode")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public ExecutableCode? ExecutableCode { get; init; }

    /// <summary>
    /// URI based data.
    /// </summary>
    [JsonPropertyName("fileData")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public FileData? FileData { get; init; }

    /// <summary>
    /// A predicted <see cref="V1Beta.FunctionCall"/> returned from the model that contains
    /// a string representing the <c>FunctionDeclaration.name</c> with the
    /// arguments and their values.
    /// </summary>
    [JsonPropertyName("functionCall")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public FunctionCall? FunctionCall { get; init; }

    /// <summary>
    /// The result output of a <see cref="V1Beta.FunctionCall"/> that contains a string
    /// representing the <c>FunctionDeclaration.name</c> and a structured JSON
    /// object containing any output from the function is used as context to
    /// the model.
    /// </summary>
    [JsonPropertyName("functionResponse")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public FunctionResponse? FunctionResponse { get; init; }

    /// <summary>
    /// Inline media bytes.
    /// </summary>
    [JsonPropertyName("inlineData")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public Blob? InlineData { get; init; }

    /// <summary>
    /// Optional. Media resolution for the input media.
    /// </summary>
    [JsonPropertyName("mediaResolution")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public MediaResolution? MediaResolution { get; init; }

    /// <summary>
    /// Custom metadata associated with the Part.
    /// Agents using genai.Part as content representation may need to keep track
    /// of the additional information. For example it can be name of a file/source
    /// from which the Part originates or a way to multiplex multiple Part streams.
    /// </summary>
    [JsonPropertyName("partMetadata")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public JsonElement PartMetadata { get; init; }

    /// <summary>
    /// Inline text.
    /// </summary>
    [JsonPropertyName("text")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public string? Text { get; init; }

    /// <summary>
    /// Optional. Indicates if the part is thought from the model.
    /// </summary>
    [JsonPropertyName("thought")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public bool? Thought { get; init; }

    /// <summary>
    /// Optional. An opaque signature for the thought so it can be reused in subsequent
    /// requests.
    /// </summary>
    [JsonPropertyName("thoughtSignature")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public string? ThoughtSignature { get; init; }

    /// <summary>
    /// Optional. Video metadata. The metadata should only be specified while the video
    /// data is presented in inline_data or file_data.
    /// </summary>
    [JsonPropertyName("videoMetadata")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public VideoMetadata? VideoMetadata { get; init; }
}

